# Security Considerations

## Overview

The Phishing Awareness Simulator is designed to educate users about phishing attacks in a **completely sandboxed environment**. No real phishing emails are sent, no real malicious links are created, and no external systems are contacted during simulations. All phishing content is rendered locally in the browser using HTML templates.

## Security Measures

### 1. Authentication & Password Security

| Measure | Implementation |
|---------|---------------|
| **Password Hashing** | bcrypt with automatic salt generation (`bcrypt.hashpw`) |
| **Session Management** | Flask-Login with server-side sessions |
| **Login Required** | `@login_required` decorator on all authenticated routes |
| **Session Cookies** | Flask's secure cookie system with `SECRET_KEY` |

**Password validation rules:**
- Minimum 8 characters (enforced by WTForms `Length` validator)
- Passwords are never stored in plaintext
- bcrypt cost factor provides protection against brute-force attacks

```python
# Password hashing (auth/routes.py)
password_hash = bcrypt.hashpw(
    password.encode('utf-8'),
    bcrypt.gensalt()
).decode('utf-8')

# Password verification
bcrypt.checkpw(
    password.encode('utf-8'),
    user.password_hash.encode('utf-8')
)
```

### 2. Cross-Site Request Forgery (CSRF) Protection

| Measure | Implementation |
|---------|---------------|
| **CSRF Tokens** | Flask-WTF `CSRFProtect` applied globally |
| **Token Injection** | Automatic `{{ form.hidden_tag() }}` in all forms |
| **Validation** | Every POST request validated server-side |

All forms include a hidden CSRF token that is validated on submission. This prevents attackers from crafting malicious forms that submit to the application on behalf of an authenticated user.

```html
<!-- Every form includes CSRF protection -->
<form method="POST">
    {{ form.hidden_tag() }}
    ...
</form>
```

### 3. SQL Injection Prevention

| Measure | Implementation |
|---------|---------------|
| **ORM** | SQLAlchemy with parameterized queries |
| **No Raw SQL** | All database operations use the ORM |

SQLAlchemy automatically parameterizes all queries, preventing SQL injection:

```python
# Safe — parameterized automatically
user = User.query.filter_by(email=email).first()
sessions = SimulationSession.query.filter_by(user_id=user_id, status='completed').all()
```

No raw SQL strings are used anywhere in the codebase.

### 4. Cross-Site Scripting (XSS) Prevention

| Measure | Implementation |
|---------|---------------|
| **Autoescaping** | Jinja2 autoescaping enabled by default |
| **Safe Markup** | `markupsafe.Markup` used only for controlled, application-generated HTML |
| **No User HTML** | User input is never rendered as raw HTML |

Jinja2's autoescaping ensures that any variable rendered in templates is HTML-escaped:

```html
<!-- Autoescaped — safe against XSS -->
<td>{{ user.username }}</td>
<p>{{ feedback_summary }}</p>
```

The only unescaped HTML is phishing content generated by `phishing_content.py`, which is application-controlled (not user-supplied).

### 5. Role-Based Access Control

| Measure | Implementation |
|---------|---------------|
| **Roles** | `student` and `instructor` stored in `users.role` |
| **Admin Guard** | `@instructor_required` decorator |
| **Defense in Depth** | Stacked decorators: `@login_required` + `@instructor_required` |

```python
def instructor_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if not current_user.is_authenticated or current_user.role != 'instructor':
            abort(403)
        return f(*args, **kwargs)
    return decorated
```

Students cannot access admin routes — the system returns HTTP 403 Forbidden.

### 6. Session Security

| Measure | Implementation |
|---------|---------------|
| **Session Ownership** | Users can only access their own simulation sessions |
| **ID Validation** | Session ownership checked before displaying data |

```python
# Verify the session belongs to the current user
session = db.session.get(SimulationSession, session_id)
if session.user_id != current_user.id:
    abort(403)
```

### 7. Input Validation

| Measure | Implementation |
|---------|---------------|
| **Form Validation** | WTForms validators (Length, Email, DataRequired, EqualTo) |
| **Uniqueness Checks** | Custom validators for duplicate username/email |
| **Type Coercion** | Integer parameters validated via Flask route converters (`<int:id>`) |

```python
# WTForms validation example
class RegistrationForm(FlaskForm):
    username = StringField('Username', validators=[
        DataRequired(), Length(min=3, max=80)
    ])
    email = StringField('Email', validators=[
        DataRequired(), Email()
    ])
    password = PasswordField('Password', validators=[
        DataRequired(), Length(min=8)
    ])
```

### 8. Sandboxed Simulation Environment

This is the most critical security consideration:

| Threat | Mitigation |
|--------|-----------|
| Real phishing emails sent | All emails are rendered as HTML in-browser; no SMTP used |
| Real malicious links | All links are dummy anchors within the simulation UI; no external navigation |
| Credential harvesting | Simulated login forms do not submit anywhere; purely visual |
| Malware delivery | No files are downloaded; all artifacts are HTML/CSS |
| Network attacks | No external connections made during simulations |

The entire simulation is a local web application. Phishing content is generated from JSON scenario data and rendered as styled HTML elements.

### 9. Data Protection

| Measure | Implementation |
|---------|---------------|
| **Minimal Data Collection** | Only username, email, and simulation data stored |
| **No Sensitive Data in URLs** | Session IDs are integers, no tokens in query strings |
| **Database File Security** | SQLite file stored in `instance/` directory (gitignored) |

### 10. Error Handling

| Measure | Implementation |
|---------|---------------|
| **404 Not Found** | Missing sessions/users return 404 (no information leakage) |
| **403 Forbidden** | Unauthorized access returns generic 403 |
| **No Stack Traces** | Debug mode disabled in production config |

## OWASP Top 10 Coverage

| OWASP Risk | Status | How Addressed |
|------------|--------|---------------|
| A01: Broken Access Control | Mitigated | Role-based access, session ownership checks, `@instructor_required` |
| A02: Cryptographic Failures | Mitigated | bcrypt password hashing, secure session cookies |
| A03: Injection | Mitigated | SQLAlchemy ORM (parameterized queries), no raw SQL |
| A04: Insecure Design | Mitigated | Sandboxed simulations, defense-in-depth decorators |
| A05: Security Misconfiguration | Mitigated | Separate config classes, debug off in production |
| A06: Vulnerable Components | Monitored | Pinned dependency versions in requirements.txt |
| A07: Auth Failures | Mitigated | bcrypt hashing, session-based auth, login required |
| A08: Software Integrity | N/A | No CI/CD pipeline, manual deployment |
| A09: Logging Failures | Partial | Actions logged in DB; application-level logging could be improved |
| A10: SSRF | N/A | Application makes no outbound HTTP requests |

## Recommendations for Production Deployment

1. **Set a strong `SECRET_KEY`** via environment variable (do not use the default dev key)
2. **Enable HTTPS** via a reverse proxy (nginx/Apache) with TLS certificates
3. **Set secure cookie flags** (`SESSION_COOKIE_SECURE=True`, `SESSION_COOKIE_HTTPONLY=True`)
4. **Add rate limiting** on login endpoints to prevent brute-force attacks
5. **Regular dependency updates** to patch known vulnerabilities
6. **Database backups** if switching to a persistent database like PostgreSQL
